1.快速排序
    原理：分治思想，将数组分成较小的子数组并递归的排序这些子数组
    步骤：
        （1）选择最后一个元素为基准值
        （2）遍历数组：将小于基准值的元素放在左侧，大于基准值的元素放在右侧
        （3）递归数组：将基准值的左侧和右侧的数组分别进行步骤1，2
    代码实现：
        ##分区
        def partition(arr, low ,high):
            pivot = arr[high] #选择最后一个元素为基准值
            i = low - 1 #i用来记录遍历数组后基准值所处的位置
            for j in range(low, high): #j用来与基准值判断大小
                if arr[j] <= pivot: #如果当前值小于基准值
                    i += 1 
                    arr[i], arr[j] = arr[j], arr[i] #交换元素，扩大小于基准值的区域
            arr[i+1], arr[high] = arr[high], arr[i+1] #将基准值放在正确的位置
            return i+1 #返回基准值索引，用于递归数组
        ##递归操作
        def quick_sort_inplace(arr, low ,high):
            if low < high:
                pi = partition(arr, low ,high)
                quick_sort_inplace(arr, low ,pi-1)
                quick_sort_inplace(arr, pi+1 ,high)
        
        arr = [10, 7 ,8 ,9 ,1 ,5]
        quick_sort_inplace(arr, 0 ,len(arr)-1)
        print(arr)
    复杂度：
        时间复杂度：0(nlogn)
        最坏情况时间复杂度：0(n^2)
        空间复杂度：0(logn)
    优点：
        （1）高效：时间复杂度比其他的排序算法快
        （2）原地排序，不需要额外空间
        （3）方便处理大规模数据
    缺点：
        （1）不稳定：会改变元素的相对顺序
        （2）最坏情况效率低0(n^2)
    leetcode：
        （1）215:第k大小元素的问题
        （2）912:对数组升序排序
        （3）347:找出出现频率最高的k个元素


2.归并排序：
    原理：分治思想，将数组分成两个子数组，分别排序后再合并
    步骤：
        （1）分解：将数组分成两部分，直到每部分剩下一个元素
        （2）合并：将两个有序的子数组组合成为一个有序的数组
        （3）递归：重复2步骤
    代码实现：
        ##合并
        def merge(left ,right):
            result = [] #存放合并后的数据
            i = j = 0 
            # 比较两个子数组的元素，并排序放入结果数组
            while i < len(left) and j < len(right):
                if left[i] <= right[j]:
                    result.append(left[i])
                    i += 1
                else:
                    result.append(right[j])
                    j += 1
            #将剩余元素追加到结果数组
            result.extend(left[i:])
            result.extend(right[j:])
            #返回两个数组拍组后的结果
            return result 
                    
        ##递归
        def merge_sort(arr):
            # 如果数组长度小于1，直接返回（说明已经找到最小的数组）
            if len(arr) <= 1:
                return arr 
            # 数组长度大于1，找到中间点
            mid = len(arr) // 2
            #递归调用归并排序
            left_half = merge_sort(arr[:mid])
            right_half = merge_sort(arr[mid:])
            #合并数组
            return merge(left_half, right_half) 

        arr = [38, 27, 43, 3, 9 ,82 ,10]
        sorted_arr = merge_sort(arr)
    复杂度：
        时间复杂度：0(nlogn)
        空间复杂度：0(n)
    优点：
        （1）稳定
        （2）适合大规模数据
    缺点：
        （1）空间复杂度：需要额外的数组储存合并结果（result）
    leetcode：
        （1）1:排序数组
        （2）2:合并两个有序链表
        （3）3.链表排序

3.堆排序


4.冒泡排序
    原理：
        交换；多次比较相邻元素的大小，将较大的元素逐步冒泡到数组的末尾
    步骤：
        （1）逐个比较相邻的元素，一轮比较后，最大的元素被移到末尾
        （2）减小比较的范围，重复1过程直到全部有序
    代码实现：
        def bubble_sort(arr):
            n = len(arr)
            #外层控制需要冒泡多少轮
            for i in range(n-1):
                #内从控制每轮需要比较多少次
                for j in range(n-1-i):#每一轮后最后一个数已经有序不需要比较
                    #如果前一个元素比后一个元素大，交换
                    if arr[j] > arr[j+1]:
                        arr[j], arr[j+1] = arr[j+1], arr[j]
            return arr 
        arr = [5,3,8,6,2]
        sorted_arr = bubble_sort(arr)
    复杂度：
        时间复杂度：最好情况0(n)
                  最差情况0(n^2)
        空间复杂度：0(1)
    优点：
        （1）稳定性好
        （2）原地排序，不需要额外空间
    缺点：
        （1）效率低
    leetcode：
        （1）912：数组排序
        （2）75:红白蓝数组排序
5.选择排序
    原理：从未排序的部分中选择最小的元素，放到以排序部分的末尾，不断重复这一过程
    步骤：
        （1）将数组分为排序部分和未排序部分
        （2）在未排序部分寻找最小值
        （3）将找到的最小元素放到已排序部分
    代码实现：
        def select_sort(arr):
            n = len(arr)
            #遍历未排序数组
            for i in range(n):
                #假设当前索引i处为最小值
                min = i 
                #在未排序部分，找到最小值
                for j in range(i+1,n):
                    if arr[j] < arr[min]:
                        min = j 
                #将最小值与当前索引值i交换
                arr[i], arr[min] = arr[min], min[i]
            return arr
        nums = [64, 25, 12, 22, 11]
        sorted_arr = select_sort(arr)
    复杂度：
        时间复杂度：0(n^2)
        空间复杂度：0(1)
    优点：
        不依赖输入数据的初始状态，时间复杂度始终一样
    缺点：
        不稳定
6.插入排序
    原理：将数组分为已排序部分和未排序部分，每次从未排序部分取出一个元素，将其插入到已排序部分的适当位置，使得已排序部分始终保持有序。

    